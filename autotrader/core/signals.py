"""
signals.py ‚Äî Trade signal objects

Bridges the scoring pipeline output to the execution engine.
A TradeSignal is the structured representation of "buy XLE at 53-53.50
with stop at 51.50 and target at 55" ‚Äî everything the executor needs
to place a bracket order without human intervention.
"""

from __future__ import annotations

import json
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional


class SignalAction(Enum):
    BUY = "BUY"
    SELL = "SELL"
    SHORT = "SHORT"
    COVER = "COVER"
    SCALE_IN = "SCALE_IN"       # Add to existing position
    SCALE_OUT = "SCALE_OUT"     # Partial exit
    CLOSE = "CLOSE"             # Full exit


class SignalSource(Enum):
    PIPELINE = "pipeline"       # From weekly/daily scoring engine
    MANUAL = "manual"           # Manually entered signal
    TRAILING = "trailing"       # Generated by trailing stop logic
    CIRCUIT_BREAKER = "circuit" # Generated by risk engine


class StructureType(Enum):
    MOMENTUM = "Momentum"
    BREAKOUT = "Breakout"
    REVERSAL = "Reversal"
    CONSOLIDATION = "Consolidation"
    UPTREND = "Uptrend"
    RANGE_WEAK = "Range/Weak"
    UNKNOWN = "Unknown"


@dataclass
class TradeSignal:
    """
    A complete trade signal ready for execution.

    Created by the signal engine (pipeline output parser) and consumed
    by the executor. Contains everything needed to place and manage
    an order without further human input.
    """

    # Identity
    ticker: str
    action: SignalAction
    source: SignalSource = SignalSource.PIPELINE
    signal_id: str = ""
    generated_at: str = ""

    # Pricing
    entry_price: float = 0.0                # Ideal entry (limit price)
    entry_zone_low: float = 0.0             # Buy zone bottom
    entry_zone_high: float = 0.0            # Buy zone top
    current_price: float = 0.0              # Price when signal was generated

    # Risk management
    stop_loss_price: float = 0.0            # Hard stop
    target_1_price: float = 0.0             # First profit target
    target_2_price: float = 0.0             # Second profit target
    trail_stop_pct: float = 4.0             # Trailing stop %

    # Sizing
    position_size_pct: float = 3.0          # % of equity to allocate
    position_size_usd: float = 0.0          # Dollar amount (calculated later)
    qty: int = 0                            # Share count (calculated later)

    # Context from pipeline
    bullish_score: float = 0.0
    crowding_score: float = 0.0
    surge_score: float = 0.0
    trend_score: float = 0.0
    momentum_score: float = 0.0
    options_score: float = 0.0
    darkpool_score: float = 0.0

    structure: StructureType = StructureType.UNKNOWN
    sector: str = ""
    overextended: bool = False

    # Holding rules
    strategy_type: str = "swing"            # momentum_breakout, mean_reversion, etc.
    max_hold_days: int = 14
    entry_expiry_minutes: int = 60          # Cancel unfilled entry after N min

    # Scale-out plan
    scale_out_at_target_1: float = 50.0     # % to sell at T1
    scale_out_at_target_2: float = 30.0     # % to sell at T2
    trail_remainder_pct: float = 20.0       # % to trail

    # Metadata
    notes: str = ""
    confidence: str = "medium"              # low, medium, high
    priority: int = 5                       # 1=highest priority, 10=lowest

    def __post_init__(self):
        self.ticker = self.ticker.upper().strip()
        if not self.generated_at:
            self.generated_at = datetime.now().isoformat()
        if not self.signal_id:
            self.signal_id = f"{self.ticker}_{self.action.value}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

        # Auto-calculate entry zone midpoint if not set
        if self.entry_price == 0 and self.entry_zone_low > 0 and self.entry_zone_high > 0:
            self.entry_price = (self.entry_zone_low + self.entry_zone_high) / 2

    # ----- VALIDATION -----

    def validate(self) -> List[str]:
        """Return list of validation errors. Empty = valid."""
        errors = []
        if not self.ticker:
            errors.append("Missing ticker")
        if self.action == SignalAction.BUY:
            if self.entry_price <= 0 and self.entry_zone_low <= 0:
                errors.append("Buy signal needs entry price or entry zone")
            if self.stop_loss_price <= 0:
                errors.append("Buy signal requires stop loss price")
            if self.stop_loss_price >= self.entry_price > 0:
                errors.append(f"Stop loss ({self.stop_loss_price}) must be below entry ({self.entry_price})")
            if self.target_1_price > 0 and self.target_1_price <= self.entry_price:
                errors.append(f"Target 1 ({self.target_1_price}) must be above entry ({self.entry_price})")
        if self.position_size_pct <= 0:
            errors.append("Position size must be > 0")
        return errors

    @property
    def is_valid(self) -> bool:
        return len(self.validate()) == 0

    @property
    def risk_reward_ratio(self) -> float:
        """Calculate R:R based on entry, stop, and target 1."""
        if self.entry_price > 0 and self.stop_loss_price > 0 and self.target_1_price > 0:
            risk = self.entry_price - self.stop_loss_price
            reward = self.target_1_price - self.entry_price
            if risk > 0:
                return round(reward / risk, 2)
        return 0.0

    @property
    def risk_pct(self) -> float:
        """Percent risk from entry to stop."""
        if self.entry_price > 0 and self.stop_loss_price > 0:
            return round((self.entry_price - self.stop_loss_price) / self.entry_price * 100, 2)
        return 0.0

    # ----- SIZING -----

    def calculate_sizing(self, account_equity: float, max_position_pct: float,
                         max_risk_per_trade_pct: float) -> None:
        """
        Calculate position size based on account equity and risk parameters.

        Uses the smaller of:
        1. Max position % of equity
        2. Max risk per trade (risk-based sizing)
        """
        # Method 1: Percentage-of-equity sizing
        pct_size = account_equity * (self.position_size_pct / 100.0)

        # Method 2: Risk-based sizing (Kelly-lite)
        # If we risk max_risk_per_trade_pct of equity, how many shares?
        if self.entry_price > 0 and self.stop_loss_price > 0:
            risk_per_share = self.entry_price - self.stop_loss_price
            if risk_per_share > 0:
                max_risk_usd = account_equity * (max_risk_per_trade_pct / 100.0)
                risk_size = (max_risk_usd / risk_per_share) * self.entry_price
            else:
                risk_size = pct_size
        else:
            risk_size = pct_size

        # Take the more conservative of the two
        self.position_size_usd = min(pct_size, risk_size)

        # Cap at max position %
        max_usd = account_equity * (max_position_pct / 100.0)
        self.position_size_usd = min(self.position_size_usd, max_usd)

        # Calculate share count
        if self.entry_price > 0:
            self.qty = int(self.position_size_usd / self.entry_price)

    # ----- SERIALIZATION -----

    def to_dict(self) -> dict:
        d = asdict(self)
        d["action"] = self.action.value
        d["source"] = self.source.value
        d["structure"] = self.structure.value
        return d

    def to_json(self) -> str:
        return json.dumps(self.to_dict(), indent=2)

    @classmethod
    def from_dict(cls, d: dict) -> TradeSignal:
        d["action"] = SignalAction(d["action"])
        d["source"] = SignalSource(d.get("source", "pipeline"))
        d["structure"] = StructureType(d.get("structure", "Unknown"))
        return cls(**d)

    def __str__(self):
        return (
            f"Signal: {self.action.value} {self.ticker} | "
            f"Entry: ${self.entry_price:.2f} [{self.entry_zone_low:.2f}-{self.entry_zone_high:.2f}] | "
            f"Stop: ${self.stop_loss_price:.2f} | T1: ${self.target_1_price:.2f} | "
            f"R:R {self.risk_reward_ratio} | Score: {self.bullish_score:.0f} | "
            f"{self.structure.value} | Size: {self.qty} shares (${self.position_size_usd:,.0f})"
        )


# ---------------------------------------------------------------------------
# SIGNAL FACTORY ‚Äî Convert pipeline output rows to TradeSignal objects
# ---------------------------------------------------------------------------

def pipeline_row_to_signal(row: dict, account_equity: float = 100000) -> Optional[TradeSignal]:
    """
    Convert a row from the daily/weekly pipeline output into a TradeSignal.

    Expects keys matching our pipeline columns:
    ticker, price, bullish_setup_score, crowding_score, surge_score,
    trend_score, momentum_score, options_score, darkpool_score,
    urkel_structure, sector, pct_above_sma20, overextended_flag,
    action_recommendation, sma20, sma50, sma200
    """
    ticker = row.get("ticker", "")
    if not ticker:
        return None

    price = float(row.get("price", 0))
    if price <= 0:
        return None

    score = float(row.get("bullish_setup_score", 0))
    action_rec = str(row.get("action_recommendation", ""))

    # Only generate BUY signals for actionable recommendations
    if "New Entry" not in action_rec and "Add" not in action_rec and "Starter" not in action_rec:
        return None

    # Map structure
    struct_str = str(row.get("urkel_structure", "Unknown"))
    try:
        structure = StructureType(struct_str)
    except ValueError:
        structure = StructureType.UNKNOWN

    # Calculate entry zone, stop, targets based on structure
    sma20 = float(row.get("sma20", price * 0.97))
    sma50 = float(row.get("sma50", price * 0.94))

    if structure == StructureType.MOMENTUM:
        entry_low = price * 0.99          # Tight entry on momentum
        entry_high = price * 1.005
        stop = max(sma20 * 0.98, price * 0.95)
        target1 = price * 1.04
        target2 = price * 1.08
        hold_days = 5
        strategy = "momentum_breakout"

    elif structure == StructureType.BREAKOUT:
        entry_low = price * 0.985
        entry_high = price * 1.005
        stop = max(sma50 * 0.98, price * 0.94)
        target1 = price * 1.05
        target2 = price * 1.10
        hold_days = 7
        strategy = "momentum_breakout"

    elif structure == StructureType.REVERSAL:
        entry_low = price * 0.97
        entry_high = price * 0.995
        stop = price * 0.92
        target1 = price * 1.06
        target2 = price * 1.12
        hold_days = 10
        strategy = "mean_reversion"

    else:  # Consolidation, Uptrend, etc.
        entry_low = price * 0.98
        entry_high = price * 1.002
        stop = price * 0.94
        target1 = price * 1.05
        target2 = price * 1.10
        hold_days = 10
        strategy = "swing"

    # Confidence mapping
    if score >= 75:
        confidence = "high"
        size_pct = 4.0
        priority = 2
    elif score >= 65:
        confidence = "medium"
        size_pct = 3.0
        priority = 5
    else:
        confidence = "low"
        size_pct = 2.0
        priority = 8

    signal = TradeSignal(
        ticker=ticker,
        action=SignalAction.BUY,
        source=SignalSource.PIPELINE,
        entry_price=round((entry_low + entry_high) / 2, 2),
        entry_zone_low=round(entry_low, 2),
        entry_zone_high=round(entry_high, 2),
        current_price=price,
        stop_loss_price=round(stop, 2),
        target_1_price=round(target1, 2),
        target_2_price=round(target2, 2),
        position_size_pct=size_pct,
        bullish_score=score,
        crowding_score=float(row.get("crowding_score", 0)),
        surge_score=float(row.get("surge_score", 0)),
        trend_score=float(row.get("trend_score", 0)),
        momentum_score=float(row.get("momentum_score", 0)),
        options_score=float(row.get("options_score", 0)),
        darkpool_score=float(row.get("darkpool_score", 0)),
        structure=structure,
        sector=str(row.get("sector", "")),
        overextended=bool(row.get("overextended_flag", False)),
        strategy_type=strategy,
        max_hold_days=hold_days,
        confidence=confidence,
        priority=priority,
    )

    # Calculate sizing
    signal.calculate_sizing(
        account_equity=account_equity,
        max_position_pct=5.0,
        max_risk_per_trade_pct=1.0,
    )

    return signal


# ---------------------------------------------------------------------------
# EXAMPLE / TEST
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    # Simulate a pipeline row for XLE
    sample_row = {
        "ticker": "XLE",
        "price": 54.00,
        "bullish_setup_score": 76.7,
        "crowding_score": 93.7,
        "surge_score": 45.0,
        "trend_score": 80.0,
        "momentum_score": 62.0,
        "options_score": 70.0,
        "darkpool_score": 55.0,
        "urkel_structure": "Breakout",
        "sector": "Energy",
        "pct_above_sma20": 4.5,
        "overextended_flag": False,
        "action_recommendation": "üü¢ New Entry",
        "sma20": 52.50,
        "sma50": 51.00,
        "sma200": 48.50,
    }

    signal = pipeline_row_to_signal(sample_row, account_equity=100000)
    if signal:
        print("Generated Signal:")
        print(signal)
        print(f"\nValidation: {'PASS' if signal.is_valid else 'FAIL'}")
        errors = signal.validate()
        if errors:
            for e in errors:
                print(f"  ‚ùå {e}")
        print(f"\nRisk/Reward:  {signal.risk_reward_ratio}:1")
        print(f"Risk per trade: {signal.risk_pct}%")
        print(f"Position size:  ${signal.position_size_usd:,.0f} ({signal.qty} shares)")
        print(f"\nFull JSON:")
        print(signal.to_json())
